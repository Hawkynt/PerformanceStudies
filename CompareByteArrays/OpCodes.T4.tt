<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

using System.Runtime.CompilerServices;
using word=System.Int16;
using dword = System.Int32;
using qword = System.Int64;
using dqword = System.Runtime.Intrinsics.Vector128<byte>;
using qqword = System.Runtime.Intrinsics.Vector256<byte>;
using dqqword = System.Runtime.Intrinsics.Vector512<byte>;

namespace Corlib;

internal static unsafe partial class OpCodes {

<#foreach(var type in new[]{"byte","word","dword","qword"}){#>

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsEqual(<#=type#> v0, <#=type#> v1) => v0 == v1;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsEqual(<#=type#> v0, byte* mem) => v0 == *(<#=type#>*)mem;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsEqual(<#=type#> v0, byte* mem, int offset) => v0 == *(<#=type#>*)(mem + offset);

<#}#>

<#foreach(var type in new[]{"dqword","qqword","dqqword"}){#>

#if SUPPORTS_VECTOR_IS_HARDWARE_ACCELERATED

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsEqual(<#=type#> v0, <#=type#> v1) => v0 == v1;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsEqual(<#=type#> v0, byte* mem) => v0 == *(<#=type#>*)mem;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsEqual(<#=type#> v0, byte* mem, int offset) => v0 == *(<#=type#>*)(mem + offset);

#else

  public static bool IsEqual(<#=type#> v0, <#=type#> v1) {
    if (RuntimeConfiguration.IsLongHardwareAccelerated) {
      var r0 = (qword*)&v0;
      var r1 = (qword*)&v1;
      for (var i = 0; i < <#=GetQWordCount(type)#>; ++i)
        if (r0[i] != r1[i])
          return false;
    } else {
      var e0 = (dword*)&v0;
      var e1 = (dword*)&v1;
      for (var i = 0; i < <#=GetDWordCount(type)#>; ++i)
        if (e0[i] != e1[i])
          return false;
    }

    return true;
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsEqual(<#=type#> v0, byte* mem) => IsEqual(v0, *(<#=type#>*)mem);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsEqual(<#=type#> v0, byte* mem, int offset) => IsEqual(v0, mem + offset);

#endif

<#}#>

<#foreach(var operation in new[]{("Or","|"),("And","&"),("Xor","^")}){#>
<#  foreach(var type in new[]{"byte","word","dword","qword"}){#>

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> <#=operation.Item1#>(<#=type#> v0, <#=type#> v1) => (<#=type#>)(v0 <#=operation.Item2#> v1);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> <#=operation.Item1#>(<#=type#> v0, byte* mem) => (<#=type#>)(v0 <#=operation.Item2#> *(<#=type#>*)mem);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> <#=operation.Item1#>(<#=type#> v0, byte* mem, int offset) => (<#=type#>)(v0 <#=operation.Item2#> *(<#=type#>*)(mem + offset));

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void <#=operation.Item1#>(ref <#=type#> v0, <#=type#> v1) => v0 <#=operation.Item2#>= v1;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void <#=operation.Item1#>(ref <#=type#> v0, byte* mem) => v0 <#=operation.Item2#>= *(<#=type#>*)mem;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void <#=operation.Item1#>(ref <#=type#> v0, byte* mem, int offset) => v0 <#=operation.Item2#>= *(<#=type#>*)(mem + offset);

<#  }#>
<#}#>
<#foreach(var operation in new[]{("Or","|"),("And","&"),("Xor","^")}){#>
<#  foreach(var type in new[]{"dqword","qqword","dqqword"}){#>

#if SUPPORTS_VECTOR_IS_HARDWARE_ACCELERATED

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> <#=operation.Item1#>(<#=type#> v0, <#=type#> v1) => (<#=type#>)(v0 <#=operation.Item2#> v1);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> <#=operation.Item1#>(<#=type#> v0, byte* mem) => (<#=type#>)(v0 <#=operation.Item2#> *(<#=type#>*)mem);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> <#=operation.Item1#>(<#=type#> v0, byte* mem, int offset) => (<#=type#>)(v0 <#=operation.Item2#> *(<#=type#>*)(mem + offset));

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void <#=operation.Item1#>(ref <#=type#> v0, <#=type#> v1) => v0 <#=operation.Item2#>= v1;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void <#=operation.Item1#>(ref <#=type#> v0, byte* mem) => v0 <#=operation.Item2#>= *(<#=type#>*)mem;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void <#=operation.Item1#>(ref <#=type#> v0, byte* mem, int offset) => v0 <#=operation.Item2#>= *(<#=type#>*)(mem + offset);

#else

  public static <#=type#> <#=operation.Item1#>(<#=type#> v0, <#=type#> v1) {
    <#=type#> result = default;
    if (RuntimeConfiguration.IsLongHardwareAccelerated) {
      var r0 = (qword*)&v0;
      var r1 = (qword*)&v1;
      var r2 = (qword*)&result;
      for (var i = 0; i < <#=GetQWordCount(type)#>; ++i)
        r2[i] = r0[i] <#=operation.Item2#> r1[i];
    } else {
      var e0 = (dword*)&v0;
      var e1 = (dword*)&v1;
      var e2 = (dword*)&result;
      for (var i = 0; i < <#=GetDWordCount(type)#>; ++i)
        e2[i] = e0[i] <#=operation.Item2#> e1[i];
    }
    return result;
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> <#=operation.Item1#>(<#=type#> v0, byte* mem) => <#=operation.Item1#>(v0, *(<#=type#>*)mem);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> <#=operation.Item1#>(<#=type#> v0, byte* mem, int offset) => <#=operation.Item1#>(v0, *(<#=type#>*)(mem + offset));

  public static void <#=operation.Item1#>(ref <#=type#> v0, <#=type#> v1) {
    fixed (<#=type#>* pv0 = &v0) {
      var r0 = (qword*)pv0;
      var r1 = (qword*)&v1;
      for (var i = 0; i < <#=GetQWordCount(type)#>; ++i)
        r0[i] <#=operation.Item2#>= r1[i];
    }
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void <#=operation.Item1#>(ref <#=type#> v0, byte* mem) => <#=operation.Item1#>(ref v0, *(<#=type#>*)mem);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void <#=operation.Item1#>(ref <#=type#> v0, byte* mem, int offset) => <#=operation.Item1#>(ref v0, *(<#=type#>*)(mem + offset));

#endif

<#  }#>
<#}#>

}
<#+
int GetDWordCount(string type) => GetQWordCount(type) * 2;
int GetQWordCount(string type) => type == "dqword" ? 2 : type == "qqword" ? 4 : type == "dqqword" ? 8 : -1;
#>